# -*- coding: utf-8 -*-
"""IPL_Match_prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mSCAslxHUVflmVOf7blcWHZBOA6H0UQj

# **Week 1-2**: Data Acquisition & Exploratory Analysis

Acquire and merge IPL datasets (ball-by-ball, match summaries).Here i have used **IPL Ball By Ball 2008 to 2025** dataset from kaggle.com , [click here ](https://www.kaggle.com/datasets/dgsports/ipl-ball-by-ball-2008-to-2022/data)to see the dataset.
"""

import pandas as pd
ball_by_ball = pd.read_csv("IPL_ball_by_ball_updated.csv")
matches = pd.read_csv("matches_updated_ipl_upto_2025.csv")

print("Size of ball_by_ball.csv is : ", ball_by_ball.shape)
print("Size of matches.csv is : ", matches.shape)

print("Columns in ball_by_ball.csv are : ", ball_by_ball.columns)
print("Columns in matches.csv are : ", matches.columns)

#merge the Dataframe:

matches = matches.rename(columns={'matchId': 'match_id'})

# Select only required match-level columns
match_cols = [
    'match_id',
    'team1',
    'team2',
    'toss_winner',
    'toss_decision',
    'neutralvenue',
    'winner',
    'match_number',
    'city',
    'winner_runs',
    'player_of_match'
]

# Merge safely
df = ball_by_ball.merge(
    matches[match_cols],
    on='match_id',
    how='left'
)

# Check result
df.head(5)

print("Size of df is : ", df.shape)

print("Columns in df are : ", df.columns)

#save our dataframe

df.to_csv("merged_dataset_IPL_match_prediction.csv",index=False)

"""Inspect data schema, quality, and distributions."""

df=pd.read_csv("merged_dataset_IPL_match_prediction.csv",
    low_memory=False)

print("Shape: (row x columns)",df.shape)

#display dataset schema and quality
df.info()

#display distibution.
df.describe()

"""Clean data: handle missing values, normalize columns, ensure
date formats.
"""

# Ensure correct date format
df['start_date'] = pd.to_datetime(df['start_date'], errors='coerce')


# Handle missing values


# Extras-related columns -> NaN means no extra on that delivery
extra_cols = ['wides', 'noballs', 'byes', 'legbyes', 'penalty']
df[extra_cols] = df[extra_cols].fillna(0)


# wicket_type NaN means no wicket
df['wicket_type'] = df['wicket_type'].fillna('No Wicket')

# Neutral venue -> missing means non-neutral
df['neutralvenue'] = df['neutralvenue'].fillna('False')

# Winner -> missing means no result / abandoned
df['winner'] = df['winner'].fillna('No Result')

# City -> missing city information
df['city'] = df['city'].fillna('Unknown')

# Match number -> missing for early seasons
df['match_number'] = df['match_number'].fillna(-1).astype(int)

# Winner runs -> NaN for matches won by wickets or no result
# Keep NaN (informative), no filling required
#we will handle it during feature engineering

#display columns
print(df.columns)
#other_player_dismissed has all values NaN so remove that column
df=df.drop(['other_player_dismissed'],axis=1)

#other_wicket_type has all values NaN so remove that column also
df=df.drop(['other_wicket_type'],axis=1)


#  Normalize categorical columns


#  Team name normalization
team_mapping = {
    'Delhi Daredevils': 'Delhi Capitals',
    'Kings XI Punjab': 'Punjab Kings',
    'Rising Pune Supergiant': 'Rising Pune Supergiants',
    'Gujarat Lions': 'Gujarat Titans'
}

team_cols = [
    'batting_team', 'bowling_team', 'team1', 'team2',
    'toss_winner', 'winner'
]

for col in team_cols:
    df[col] = df[col].replace(team_mapping)

#  Player name normalization (remove extra spaces)
df['player_dismissed']=df['player_dismissed'].fillna("No dismiss")
player_cols = [
    'striker', 'non_striker', 'bowler',
    'player_dismissed', 'player_of_match'
]

for col in player_cols:
    df[col] = df[col].astype(str).str.strip()

df.info()

# save cleaned data
df.to_csv("cleaned_dataset_IPL_match_prediction.csv",index=False)

"""EDA: distributions of runs, wickets, venue stats, team performance."""

import matplotlib.pyplot as plt
import seaborn as sns

df=pd.read_csv("cleaned_dataset_IPL_match_prediction.csv",
    low_memory=False)

# Distribution of runs
plt.figure(figsize=(8,5))
sns.countplot(x='runs_off_bat', data=df)
plt.title("Distribution of Runs Scored Off the Bat per ball")
plt.xlabel("Runs Off the Bat")
plt.ylabel("Number of Deliveries")
plt.show()

# Create binary column for wickets
df['is_wicket'] = (df['wicket_type'] != 'No Wicket').astype(int)

#Distribution of wickets
plt.figure(figsize=(6,4))
sns.countplot(x='is_wicket', data=df)
plt.title("Distribution of Wickets per Ball in IPL")
plt.xlabel("Wicket (1 = Yes, 0 = No)")
plt.ylabel("Number of Deliveries")
plt.show()

# Average runs per ball by venue
venue_runs = df.groupby('venue')['runs_off_bat'].mean().sort_values(ascending=False)

# Average wicket rate per ball by venue
venue_wickets = df.groupby('venue')['is_wicket'].mean().sort_values(ascending=False)

plt.figure(figsize=(12,6))
venue_runs.plot(kind='bar', color='skyblue')
plt.title("Average Runs per Ball by Venue")
plt.xlabel("Venue")
plt.ylabel("Average Runs")
plt.xticks(rotation=45, ha='right')


plt.figure(figsize=(12,6))
venue_wickets.plot(kind='bar', color='salmon')
plt.title("Wicket Frequency per Ball by Venue")
plt.xlabel("Venue")
plt.ylabel("Wickets per Ball")
plt.xticks(rotation=45, ha='right')
plt.show()

# Average runs per ball by batting team
team_batting = df.groupby('batting_team')['runs_off_bat'].mean().sort_values(ascending=False)

plt.figure(figsize=(12,6))
team_batting.plot(kind='bar', color='skyblue')
plt.title("Average Runs per Ball by Batting Team")
plt.xlabel("Team")
plt.ylabel("Average Runs")
plt.xticks(rotation=45, ha='right')

# Average wickets per ball by bowling team
team_bowling = df.groupby('bowling_team')['is_wicket'].mean().sort_values(ascending=False)

plt.figure(figsize=(12,6))
team_bowling.plot(kind='bar', color='salmon')
plt.title("Wicket Frequency per Ball by Bowling Team")
plt.xlabel("Team")
plt.ylabel("Wickets per Ball")
plt.xticks(rotation=45, ha='right')

plt.show()

